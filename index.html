<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Kenzies Fridge</title>
<meta name="description" content="Welcome to Kenzies fridge!">
<meta name="viewport" content="width=device-width,initial-scale=1" />

<!-- Open Graph / Social -->
<meta property="og:title" content="Kenzies Fridge">
<meta property="og:description" content="Welcome to kenzies fridge!">
<meta property="og:image" content="https://raw.githubusercontent.com/kenzibets/kenztopia/main/static/image/Screenshot%202025-11-07%20122731.png">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Kenzies Fridge">
<meta name="twitter:description" content="Welcome to Kenzies fridge!">
<meta name="twitter:image" content="https://raw.githubusercontent.com/kenzibets/kenztopia/main/static/image/Screenshot%202025-11-07%20122731.png">

<link rel="icon" href="https://pngfre.com/wp-content/uploads/monster-energy-drink-37.png" />

<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;700;900&family=Nosifer&display=swap" rel="stylesheet">
<style>
:root{
  --accent-green:#0cf04a;
  --muted:#bfc7c3;
  --bg:#070606;
}
/* Base */
html,body{height:100%;margin:0;background:linear-gradient(180deg,#060606,#0b0b0b);color:#fff;font-family:Rubik,system-ui,-apple-system,"Segoe UI",Roboto,Arial;overflow:hidden}
::-webkit-scrollbar { width: 0; height: 0 }
body { scrollbar-width: none; -ms-overflow-style: none; }

/* background + green streak */
body::before{
  content:""; position:fixed; inset:0; z-index:-3;
  background:
    linear-gradient(180deg, rgba(0,0,0,0.55) 0%, rgba(8,8,8,0.85) 100%),
    url('https://source.unsplash.com/1600x900/?grunge,black,wall') center/cover no-repeat;
  mix-blend-mode:multiply; opacity:0.95;
}
body::after{
  content:""; position:fixed; left:-20%; top:-10%; width:140%; height:120%; z-index:-2;
  background: radial-gradient(40% 60% at 10% 20%, rgba(12,240,74,0.06), transparent 8%),
              radial-gradient(30% 60% at 80% 80%, rgba(12,240,74,0.035), transparent 12%);
  filter:blur(18px); pointer-events:none;
}

/* layout */
.wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:28px;overflow:auto}
.card{width:1150px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.45));border-radius:12px;padding:18px;box-shadow:0 28px 80px rgba(0,0,0,0.95);display:grid;grid-template-columns:1fr 440px;gap:18px;border:4px solid rgba(0,0,0,0.7)}
header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between;padding-bottom:6px}
header h1{margin:0;font-size:24px;letter-spacing:1px;font-weight:900;color:var(--accent-green)}
.subtitle{color:var(--muted);font-size:13px}

/* LEADERBOARD BUTTON - moved into left title area, neon green style */
#leaderboardBtn {
  margin-left:12px;
  background: linear-gradient(180deg,#0cf04a,#08a132);
  border:none;
  color:#04220b;
  padding:8px 12px;
  border-radius:10px;
  font-weight:900;
  cursor:pointer;
  box-shadow: 0 8px 30px rgba(12,240,74,0.12), 0 0 18px rgba(12,240,74,0.18), 0 0 40px rgba(12,240,74,0.06) inset;
  text-shadow: 0 1px 0 rgba(0,0,0,0.6);
}
#leaderboardBtn:hover { transform: translateY(-2px); transition: transform .12s; }

/* board */
.board-area{padding:8px;border-radius:8px;Display:flex;flex-direction:column;gap:12px;align-items:center;position:relative;overflow:visible}
.controls{display:flex;align-items:center;gap:10px;width:100%;justify-content:space-between}
.left-controls{display:flex;gap:12px;align-items:center}
.btn{background:linear-gradient(180deg,#0bf04a,#0a7e2e);border:none;padding:12px 20px;border-radius:10px;color:#050505;font-weight:900;cursor:pointer;box-shadow:0 10px 22px rgba(11,180,60,0.08)}
.small{padding:8px 12px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
input[type=number]{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;color:var(--muted);border-radius:8px}

/* board grid (5 x 3) */
.board{display:grid;grid-template-columns: repeat(5, 1fr);gap:12px;align-items:stretch;justify-items:stretch;padding:10px;background:linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.14));border-radius:12px;border-left:10px solid rgba(0,0,0,0.9);position:relative;min-height:360px}
.col{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.25));border-radius:8px;padding:10px;display:flex;flex-direction:column;gap:8px;align-items:center;justify-content:center;position:relative;border-top:6px solid rgba(0,0,0,0.9);transition:transform .18s}
.cell{width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:8px;background:rgba(0,0,0,0.04);border-radius:6px}
.cell img{width:92px;height:92px;object-fit:contain;transition:transform .35s,filter .25s}
.cell .name{font-size:12px;color:var(--muted);margin-top:8px}

/* multiplier overlay per column */
.col .col-mult{position:absolute;left:50%;transform:translateX(-50%);top:8px;font-family:"Nosifer","Rubik",sans-serif;font-size:46px;color:var(--accent-green);pointer-events:none;text-shadow:0 2px 0 rgba(0,0,0,0.9);opacity:0.95;transition:transform .25s,opacity .18s;letter-spacing:6px}
.col .col-mult.small{font-size:28px;top:auto;bottom:12px;opacity:.7}
.col .col-mult.hidden{opacity:0;transform:translateX(-50%) scale(.92)}

/* states */
.col.spinning img{transform:translateY(-6px) scale(.98)}
.col.win{box-shadow:0 12px 44px rgba(12,240,74,0.22), inset 0 0 18px rgba(12,240,74,0.06);transform:translateY(-6px);transition:transform .22s}
.col.bigwin{animation:colBig .9s ease 0s 1}
@keyframes colBig{0%{transform:scale(1)}50%{transform:scale(1.06)}100%{transform:scale(1)}}

/* info area */
.info{background:linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.18));padding:12px;border-radius:8px;display:flex;flex-direction:column;gap:12px}
.balance{font-size:36px;font-weight:900;color:var(--accent-green);letter-spacing:1px}
.muted{color:var(--muted);font-size:13px}
.payout-board{background:rgba(0,0,0,0.25);padding:12px;border-radius:6px;max-height:220px;overflow:auto;font-size:14px;line-height:1.28}
.payout-board img { width:40px;height:40px }
.history{background:rgba(0,0,0,0.2);padding:12px;border-radius:6px;max-height:260px;overflow:auto;font-size:14px;line-height:1.28}
.history-item{display:flex;justify-content:space-between;padding:6px 0;align-items:center;opacity:0;animation:slideIn .32s ease forwards}
@keyframes slideIn{to{opacity:1;transform:none}from{opacity:0;transform:translateY(-8px)}}

/* Win overlay (center) */
.win-overlay {
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%) scale(0.95);
  z-index: 10000;
  min-width: 360px;
  max-width: 86%;
  background: rgba(8,8,8,0.95);
  color: #fff;
  border-radius: 12px;
  padding: 18px 22px;
  text-align: center;
  box-shadow: 0 30px 80px rgba(0,0,0,0.8);
  pointer-events: none;
  opacity: 0;
}
.win-overlay .title { font-family: Nosifer, Rubik, sans-serif; font-size: 28px; margin: 2px 0; letter-spacing: 2px; color: var(--accent-green); }
.win-overlay .amount { font-weight: 900; font-size: 34px; margin-top: 6px; }
.win-overlay.small { background: linear-gradient(180deg, rgba(0,0,0,0.92), rgba(0,0,0,0.95)); }
.win-overlay.mid { background: linear-gradient(180deg, rgba(6,20,6,0.96), rgba(10,40,10,0.97)); border: 1px solid rgba(12,240,74,0.08); }
.win-overlay.jackpot { background: linear-gradient(180deg, rgba(50,5,5,0.96), rgba(90,10,10,0.98)); border: 2px solid rgba(255,215,0,0.18); }
.win-overlay.maxwin { background: linear-gradient(180deg, rgba(12,60,12,0.96), rgba(12,120,12,0.98)); border: 2px solid rgba(12,240,74,0.22); box-shadow: 0 40px 120px rgba(12,240,74,0.18); color: #dbffd9; }
.win-overlay.show { opacity: 1; transform: translate(-50%, -50%) scale(1); transition: all 560ms cubic-bezier(.2,.9,.2,1); pointer-events: auto; }
@keyframes popScale { 0%{transform: translate(-50%,-50%) scale(0.7)} 60%{transform: translate(-50%,-50%) scale(1.08)} 100%{transform: translate(-50%,-50%) scale(1)} }
.win-overlay.pop { animation: popScale 700ms cubic-bezier(.2,.9,.2,1); }
.win-overlay.pulse { animation: pulse 900ms ease-in-out; }
@keyframes pulse { 0% { transform: translate(-50%,-50%) scale(.9); } 50% { transform: translate(-50%,-50%) scale(1.03); } 100% { transform: translate(-50%,-50%) scale(1); } }

/* music player: compact and playlist scrolls inside box */
.player{display:flex;flex-direction:column;gap:8px;background:rgba(0,0,0,0.12);padding:8px;border-radius:8px;max-height:360px}
.player .playlist{background:rgba(0,0,0,0.06);padding:6px;border-radius:6px;max-height:140px;overflow:auto}
.player .progress{height:8px;background:rgba(255,255,255,0.04);border-radius:999px;position:relative;cursor:pointer}
.player .progress .bar{height:100%;background:linear-gradient(90deg,var(--accent-green),#6ff29a);width:0;border-radius:999px;transition:width .08s linear}
.player .time{font-size:12px;color:var(--muted);min-width:90px;text-align:right}

/* memetopia modal */
.modal-overlay { position: fixed; inset:0; background: rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; z-index:12000; pointer-events:none; opacity:0; transition:all .28s ease; }
.modal-overlay.active { pointer-events:auto; opacity:1; }
.modal { background: #0c0c0c; padding:18px 20px; border-radius:10px; color:#fff; min-width:320px; max-width:92%; text-align:center; box-shadow:0 30px 80px rgba(0,0,0,0.6); }
.continue-btn { border: none; padding:10px 16px; border-radius:8px; font-weight:900; cursor:pointer; margin-top:12px; background: linear-gradient(180deg,#0bf04a,#0a7e2e); color:#050505; }
.continue-btn.flash { animation: flashBtn 1200ms infinite; }
@keyframes flashBtn { 0%{transform:translateY(0)}50%{transform:translateY(-4px)}100%{transform:translateY(0)} }

/* responsive */
@media (max-width:1200px){ .card{width:95%} .cell img{width:72px;height:72px} }
.hidden{display:none}

/* Leaderboard modal styles (full centered modal) */
#kf-leaderboard-modal .modal { max-width:980px; width:95%; padding:20px 22px; }
.kf-leaderboard-grid { display:grid; grid-template-columns: 1fr 320px; gap:12px; align-items:start; }
.kf-leaderboard-main { background: rgba(0,0,0,0.06); padding:10px; border-radius:8px; max-height:520px; overflow:auto; }
.kf-leaderboard-right { background: rgba(0,0,0,0.04); padding:10px; border-radius:8px; max-height:520px; overflow:auto; }

/* Leaderboard hero header to look like the image */
.kf-leaderboard-hero{
  display:flex;align-items:center;gap:14px;justify-content:space-between;padding:12px 8px 6px;border-bottom:1px solid rgba(255,255,255,0.03);
}
.kf-leaderboard-hero h2{margin:0;font-size:32px;letter-spacing:2px;font-weight:900;color:#fff;text-align:center}
.kf-leaderboard-hero .muted{color:var(--muted);font-size:13px}

/* Table like the image */
.kf-table{width:100%;border-collapse:collapse;margin-top:12px}
.kf-table thead th{font-size:12px;color:var(--muted);text-align:left;padding:12px 12px;border-bottom:1px solid rgba(255,255,255,0.03);font-weight:700}
.kf-table tbody tr{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));}
.kf-table td{padding:12px;border-bottom:1px dashed rgba(255,255,255,0.03);vertical-align:middle;font-size:14px}
.kf-row-left{display:flex;align-items:center;gap:12px;min-width:0}
.kf-avatar{width:36px;height:36px;border-radius:6px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.12));display:flex;align-items:center;justify-content:center;font-weight:900;color:var(--muted);flex-shrink:0}
.kf-username{font-weight:800;max-width:220px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.kf-user-meta{display:block;color:var(--muted);font-size:12px;margin-top:4px}
.kf-perf{font-weight:900;color:var(--accent-green);font-size:15px}
.kf-perf.negative{color:#ff6b6b}
.kf-center{color:var(--muted);text-align:center;font-weight:700}
.kf-trades{color:var(--muted);text-align:right}

/* highlight current user */
.kf-table tbody tr.me{background: linear-gradient(90deg, rgba(12,240,74,0.03), rgba(255,255,255,0.01));}

/* mobile */
@media (max-width:720px){
  .kf-leaderboard-grid { grid-template-columns: 1fr; }
  .kf-leaderboard-hero h2{font-size:22px}
}

/* sell feet modal specific */
#sellFeetModal .modal { max-width:520px; width:92%; padding:20px; text-align:center; }
#sellFeetModal .title { font-size:20px; color:var(--accent-green); font-weight:900; margin-bottom:6px; }
#sellFeetModal .msg { color:#fff; margin:10px 0; font-size:15px; }
#sellFeetModal .small-muted { color:var(--muted); font-size:13px; margin-top:8px; }
#sellFeetBtn { background: linear-gradient(180deg,#ffb347,#ff7e5f); border: none; color:#050505; font-weight:900; padding:10px 12px; border-radius:8px; cursor:pointer; }
#sellFeetBtn[disabled] { opacity:0.5; cursor:not-allowed; }
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="card" role="application" id="card">
    <header>
      <div style="display:flex;align-items:center;gap:12px">
        <div>
          <h1 id="title">Kenzies Frigde <span style="font-size:12px;color:var(--muted);font-weight:600"></span></h1>
          <div class="subtitle">Welcome to kenzies fridge.</div>
        </div>
        <!-- Moved Leaderboard button here (left of slot area) -->
        <button id="leaderboardBtn" class="small">LEADERBOARD</button>
      </div>
      <div style="text-align:right">
        <!-- right side left intentionally empty as requested -->
      </div>
    </header>

    <!-- LEFT: slot board -->
    <div class="board-area" id="boardArea">
      <div class="controls">
        <div class="left-controls">
          <div>
            <div class="muted">Balance</div>
            <div id="balance" class="balance">5000.00</div>
          </div>
          <div>
            <div class="muted">Bet</div>
            <div id="betWrap"><input id="betInput" type="number" value="10" min="1" step="1" style="width:90px;"></div>
          </div>
          <button id="maxBtn" class="small">MAX</button>

          <!-- CHANGED: "Reset" button replaced with Sell Feet Pics action -->
          <button id="sellFeetBtn" class="small" title="Sell feet pics (3 uses per 24h)">SELL FEET PICS</button>

          <!-- MEMES MODE BUTTON (does NOT change colors) -->
          <button id="memesBtn" class="small">Activate Memes Mode</button>

        </div>

        <!-- Play area (SPIN + AUTO horizontally) -->
        <div style="display:flex;gap:12px;align-items:center">
          <div style="text-align:center">
            <div class="muted">Play</div>
            <div id="buttonArea" style="margin-top:6px">
              <button id="spinBtn" class="btn">SPIN</button>
              <!-- auto on the right of spin -->
              <button id="autoBtn" class="small" style="margin-left:12px">AUTO 10</button>
            </div>
            <div id="lastWin" class="muted" style="margin-top:6px">—</div>
          </div>
        </div>
      </div>

      <div class="board" id="board" aria-hidden="false"></div>

      <div class="particles" id="particles"></div>

      <!-- Minimal memesBox placeholder (kept hidden mostly) -->
      <div id="memesBox" style="display:none">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Memes mode</strong></div>
        </div>
      </div>

    </div>

    <!-- RIGHT: info + player -->
    <aside class="info" aria-label="Info & Player">
      <div>
        <div class="muted">Payout board</div>
        <div style="font-weight:700">Center-row payouts</div>
      </div>
      <div class="payout-board" id="payoutBoard"></div>

      <div>
        <div class="muted">Spin history</div>
        <div class="history" id="history"></div>
      </div>

      <div>
        <div class="muted">Music Player (background)</div>
        <div class="player">
          <div style="display:flex;gap:8px;align-items:center">
            <label class="small" style="padding:6px 8px;cursor:pointer">
              Select folder
              <input id="folderInput" type="file" webkitdirectory directory multiple style="display:none">
            </label>
            <button id="shuffleBtn" class="small">Shuffle: OFF</button>
            <button id="loopBtn" class="small">Loop: ON</button>
          </div>

          <div style="display:flex;gap:8px;align-items:center">
            <button id="prevBtn" class="small">Prev</button>
            <button id="playBtn" class="small">Play</button>
            <button id="nextBtn" class="small">Next</button>
            <input id="vol" type="range" min="0" max="1" step="0.01" value="0.7" style="flex:1">
          </div>

          <div style="display:flex;gap:8px;align-items:center">
            <div style="flex:1">
              <div class="progress" id="progress">
                <div class="bar" id="progressBar"></div>
              </div>
            </div>
            <div class="time" id="timeLabel">0:00 / 0:00</div>
          </div>

          <div class="playlist" id="playlist" aria-live="polite" style="min-height:40px"></div>
        </div>
      </div>
    </aside>
  </div>
</div>

<!-- Sell Feet Pics modal -->
<div id="sellFeetModal" class="modal-overlay" aria-hidden="true" style="display:none">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="sellFeetTitle">
    <div class="title" id="sellFeetTitle">You sold feet pics...</div>
    <div class="msg" id="sellFeetMsg">You lost your dignity and made $0.00 from selling feet pics... yikes man leave the feet pic business to rudy!</div>
    <div class="small-muted" id="sellFeetInfo"></div>
    <div style="margin-top:12px;display:flex;gap:10px;justify-content:center">
      <button id="sellFeetClose" class="continue-btn">OK</button>
    </div>
  </div>
</div>

<!-- Memetopia modal (explanatory text, doesn't show counts) -->
<div id="memetopiaModal" class="modal-overlay" aria-hidden="true" style="display:none">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="memetopiaTitle">
    <h2 id="memetopiaTitle">Memetopia</h2>
    <p id="memetopiaBody">Memetopia replaces standard slot symbols with images (including animated GIFs) and plays win/lose sounds from the repo. Use it to personalize the slot with memes and audio hosted in the repository folders. Press Continue to proceed.</p>
    <button id="memetopiaContinue" class="continue-btn flash">CONTINUE</button>
  </div>
</div>

<!-- Win overlay (count-up and per-win animation) -->
<div id="winOverlay" class="win-overlay hidden" aria-hidden="true">
  <div class="title" id="winTitle">YOU WIN</div>
  <div class="amount" id="winAmount">$0.00</div>
  <div class="subtitle muted" id="winSub" style="margin-top:6px;font-size:13px"></div>
</div>

<script>
/* Single-file client-side slot machine (static)
   Edits applied:
    - Win Rate column now uses user.performance first (but still labeled "Win Rate").
    - Memes mode made harder to win (probabilistic gates).
    - General house-edge dampening for big wins preserved/adjusted.
    - Initial balance remains 5000.
*/

/* ---------------------------
   Constants (symbols, weights) - tuned for more common small wins and rarer big wins
   --------------------------- */
const symbolImages = [
    'https://github.com/kenzibets/socials/raw/main/green.png',
    'https://github.com/kenzibets/socials/raw/main/red.png',
    'https://github.com/kenzibets/socials/raw/main/white.png',
    'https://pngfre.com/wp-content/uploads/monster-energy-drink-56.png',
    'https://pngfre.com/wp-content/uploads/monster-energy-drink-51.png',
    'https://pngfre.com/wp-content/uploads/monster-energy-drink-50.png',
    'https://pngfre.com/wp-content/uploads/monster-energy-drink-71.png',
    'https://pngfre.com/wp-content/uploads/Monster-8.png',
    'https://pngfre.com/wp-content/uploads/Monster-24.png'
];

/*
  New multipliers:
   - ids 0..5 are low/mid tier => more frequent small wins
   - ids 6..8 are rarer high tiers => big wins much less frequent
*/
const SYMBOLS = [
    {"id": 0, "name": "Green Slash", "img": symbolImages[0], "mult3": 8,  "mult2": 2.0},   // very common small
    {"id": 1, "name": "Red Slash",   "img": symbolImages[1], "mult3": 6,  "mult2": 1.8},
    {"id": 2, "name": "White Slash", "img": symbolImages[2], "mult3": 5,  "mult2": 1.5},
    {"id": 3, "name": "Monster A",   "img": symbolImages[3], "mult3": 12, "mult2": 2.2},   // mid
    {"id": 4, "name": "Monster B",   "img": symbolImages[4], "mult3": 10, "mult2": 2.0},
    {"id": 5, "name": "Monster C",   "img": symbolImages[5], "mult3": 7,  "mult2": 1.4},
    {"id": 6, "name": "Monster D",   "img": symbolImages[6], "mult3": 40, "mult2": 6.0},   // rare big
    {"id": 7, "name": "Monster E",   "img": symbolImages[7], "mult3": 25, "mult2": 3.5},   // rarer
    {"id": 8, "name": "Monster F",   "img": symbolImages[8], "mult3": 15, "mult2": 2.5},   // rare-ish
];

/* Weighted pool favors low-tier ids heavily, high-tier ids lightly */
const WEIGHTED_SYMBOL_IDS = (
  Array(40).fill(0)   // id0 very common
  .concat(Array(36).fill(1))
  .concat(Array(30).fill(2))
  .concat(Array(20).fill(3))
  .concat(Array(16).fill(4))
  .concat(Array(12).fill(5))
  .concat(Array(3).fill(6))   // rare
  .concat(Array(6).fill(7))
  .concat(Array(10).fill(8))
);

/* Board */
const COLUMNS = 5;
const ROWS = 3;

/* GitHub API endpoints (your repo) */
const GITHUB_API_BASE = 'https://api.github.com/repos/kenzibets/monsterslots/contents';
const MEMES_DIR = 'static/memes';
const AUDIO_WINS_DIR = 'static/audios/wins';
const AUDIO_LOSE_DIR = 'static/audios/lose';

/* App state */
const INITIAL_BALANCE = 5000.00;
let balance = INITIAL_BALANCE;
let autoRunning = false;
let autoLeft = 0;
let winShowing = false; // prevents spin while overlay visible

/* DOM refs */
const balanceEl = document.getElementById('balance');
const betInput = document.getElementById('betInput');
const betWrap = document.getElementById('betWrap');
const spinBtn = document.getElementById('spinBtn');
const autoBtn = document.getElementById('autoBtn');
const lastWin = document.getElementById('lastWin');
const boardEl = document.getElementById('board');
const payoutBoardEl = document.getElementById('payoutBoard');
const historyEl = document.getElementById('history');
const maxBtn = document.getElementById('maxBtn');
// replaced clearBtn with sellFeetBtn
const sellFeetBtn = document.getElementById('sellFeetBtn');
const particlesRoot = document.getElementById('particles');

const memesBtn = document.getElementById('memesBtn');
const memetopiaModal = document.getElementById('memetopiaModal');
const memetopiaContinue = document.getElementById('memetopiaContinue');
const memetopiaBody = document.getElementById('memetopiaBody');

const folderInput = document.getElementById('folderInput'); // local music loader
const playlistEl = document.getElementById('playlist');
const playBtn = document.getElementById('playBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const vol = document.getElementById('vol');
const loopBtn = document.getElementById('loopBtn');
const shuffleBtn = document.getElementById('shuffleBtn');
const progress = document.getElementById('progress');
const progressBar = document.getElementById('progressBar');
const timeLabel = document.getElementById('timeLabel');

const winOverlay = document.getElementById('winOverlay');
const winTitle = document.getElementById('winTitle');
const winAmountEl = document.getElementById('winAmount');
const winSub = document.getElementById('winSub');

const sellFeetModal = document.getElementById('sellFeetModal');
const sellFeetMsg = document.getElementById('sellFeetMsg');
const sellFeetInfo = document.getElementById('sellFeetInfo');
const sellFeetClose = document.getElementById('sellFeetClose');

let playlist = []; // background music playlist
let audio = new Audio();
audio.volume = Number(vol.value);
let currentIndex = 0;
let loopAudio = true;
let shuffleAudio = false;
loopBtn.textContent = 'Loop: ON';
shuffleBtn.textContent = 'Shuffle: OFF';

/* Memes & SFX state */
let memeImages = [];   // [{name, displayName, url}]
let memeSymbols = [];  // [{ id, name, img, mult3, mult2, winName }]
let sfxWins = [];      // [{name, url}]
let sfxLose = [];      // [{name, url}]
let memesMode = false;

/* helpers */
function setBalance(v){ balance = Math.max(0, Math.round(v*100)/100); balanceEl.textContent = balance.toFixed(2); window.balance = balance; }
setBalance(balance);

function fmtTime(s){ if(!isFinite(s)) return '0:00'; s = Math.max(0, Math.floor(s)); return Math.floor(s/60) + ':' + (s%60<10 ? '0'+(s%60) : (s%60)); }

/* Build board */
function buildBoard(){
  boardEl.innerHTML = '';
  for(let c=0;c<COLUMNS;c++){
    const col = document.createElement('div');
    col.className = 'col';
    col.id = `col-${c}`;
    const mult = document.createElement('div');
    mult.className = 'col-mult hidden';
    mult.id = `col-mult-${c}`;
    mult.textContent = 'X1';
    col.appendChild(mult);
    for(let r=0;r<ROWS;r++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.innerHTML = `<img src="" alt=""><div class="name">---</div>`;
      col.appendChild(cell);
    }
    boardEl.appendChild(col);
  }
}
buildBoard();

/* payout board (will show SYMBOLS normally or memes when memesMode active) */
function populatePayoutBoard(){
  payoutBoardEl.innerHTML = '';
  if(memesMode && memeSymbols.length){
    // Show memes with their payouts and win names
    // Sort by mult3 desc
    const sorted = memeSymbols.slice().sort((a,b)=>b.mult3 - a.mult3);
    for(const s of sorted){
      const row = document.createElement('div');
      row.className = 'payout-row';
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '6px 0';
      row.style.alignItems = 'center';
      row.style.padding = '6px 0';
      row.innerHTML = `
        <div style="display:flex;gap:12px;align-items:center;min-width:0">
          <img src="${s.img}" style="width:40px;height:40px;object-fit:contain">
          <div style="line-height:1;min-width:0">
            <div style="font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:240px">${s.winName}</div>
            <div class="muted" style="font-size:12px">3+ center → ${s.mult3}x • pair → ${s.mult2}x</div>
          </div>
        </div>
        <div style="text-align:right"><div class="muted" style="font-size:13px">meme ${s.id}</div></div>
      `;
      payoutBoardEl.appendChild(row);
    }
    // Add Max Win descriptor at top
    const maxRow = document.createElement('div');
    maxRow.style.padding = '8px 0';
    maxRow.style.borderTop = '1px dashed rgba(255,255,255,0.04)';
    maxRow.style.marginTop = '6px';
    maxRow.innerHTML = `<div style="font-weight:900;color:var(--accent-green)">MAX WIN — All slots show distinct memes (bigger than JACKPOT)</div><div class="muted" style="font-size:12px">Triggers when center row contains distinct meme images across all columns.</div>`;
    payoutBoardEl.prepend(maxRow);
  } else {
    // default SYMBOLS
    const sorted = SYMBOLS.slice().sort((a,b)=>b.mult3 - a.mult3);
    for(const s of sorted){
      const row = document.createElement('div');
      row.className = 'payout-row';
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '6px 0';
      row.innerHTML = `
        <div style="display:flex;gap:12px;align-items:center;min-width:0">
          <img src="${s.img}" style="width:40px;height:40px;object-fit:contain">
          <div style="line-height:1;min-width:0">
            <div style="font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:240px">${s.name}</div>
            <div class="muted" style="font-size:12px">3+ center → ${s.mult3}x • pair → ${s.mult2}x</div>
          </div>
        </div>
        <div style="text-align:right"><div class="muted" style="font-size:13px">id ${s.id}</div></div>
      `;
      payoutBoardEl.appendChild(row);
    }
  }
}
populatePayoutBoard();

/* random util */
function randInt(max){ return Math.floor(Math.random()*max); }

/* animate helpers */
function burstAt(x,y,color='rgba(12,240,74,0.95)'){
  const count = 18;
  for(let i=0;i<count;i++){
    const p = document.createElement('div');
    p.style.position='absolute';
    p.style.left = `${x}px`; p.style.top = `${y}px`;
    p.style.width='8px'; p.style.height='8px'; p.style.borderRadius='50%';
    p.style.background = color; p.style.opacity = Math.random()*0.9 + 0.3;
    p.style.pointerEvents = 'none'; p.style.mixBlendMode = 'screen';
    particlesRoot.appendChild(p);
    const angle = Math.random()*Math.PI*2;
    const dist = 20 + Math.random()*80;
    const dx = Math.cos(angle)*dist; const dy = Math.sin(angle)*dist;
    p.animate([{ transform: `translate(0px,0px) scale(1)`, opacity: p.style.opacity },{ transform: `translate(${dx}px,${dy}px) scale(.6)`, opacity: 0 }], { duration: 700 + Math.random()*400, easing: 'cubic-bezier(.16,.85,.4,1)'});
    setTimeout(()=> p.remove(), 1200);
  }
}
function cameraShake(intensity = 6){
  const card = document.getElementById('card');
  const dist = intensity;
  card.animate([{ transform: 'translateY(0)' },{ transform: `translateY(-${dist}px)` },{ transform: `translateY(${Math.round(dist/2)}px)` },{ transform: `translateY(-${Math.round(dist/3)}px)` },{ transform: 'translateY(0)' }], { duration: 700, iterations: 1, easing: 'cubic-bezier(.16,.85,.4,1)'});
}

/* animate single column (concurrent spin) */
function animateColumn(colIndex, finalColSymbols){
  return new Promise(res=>{
    const colEl = document.getElementById(`col-${colIndex}`);
    const imgs = colEl.querySelectorAll('.cell img');
    const names = colEl.querySelectorAll('.cell .name');
    colEl.classList.add('spinning');
    const ints = [];
    for(let r=0;r<ROWS;r++){
      ints[r] = setInterval(()=>{
        if(memesMode && memeImages.length > 0){
          const pick = memeImages[randInt(memeImages.length)];
          imgs[r].src = pick.url;
          names[r].textContent = pick.displayName;
        } else {
          const s = SYMBOLS[randInt(SYMBOLS.length)];
          imgs[r].src = s.img;
          names[r].textContent = s.name;
        }
      }, 50);
    }
    for(let r=0;r<ROWS;r++){
      const stopAt = 360 + r*90 + Math.random()*120;
      setTimeout(()=>{
        clearInterval(ints[r]);
        if(memesMode && memeImages.length > 0){
          const serverId = finalColSymbols[r].id;
          // finalColSymbols[r] is a memeSymbol entry
          const memePick = memeSymbols[serverId % memeSymbols.length];
          imgs[r].src = memePick.img;
          names[r].textContent = memePick.winName;
        } else {
          imgs[r].src = finalColSymbols[r].img;
          names[r].textContent = finalColSymbols[r].name;
        }
        imgs[r].animate([{ transform: 'translateY(-8px) scale(.96)' }, { transform: 'translateY(0) scale(1)' }], { duration: 300, easing: 'cubic-bezier(.2,.9,.2,1)' });
      }, stopAt);
    }
    const finishAt = 360 + (ROWS-1)*90 + 220;
    setTimeout(()=>{ colEl.classList.remove('spinning'); res(); }, finishAt+80);
  });
}

/* determine winners on center row */
function winningIndicesCenter(resp){
  if(!resp || resp.win_type === 'none') return [];
  const center = resp.center_row;
  if(resp.win_type === 'maxwin'){
    // all distinct center slots -> highlight all columns
    return [...Array(center.length).keys()];
  }
  if(resp.win_type === '3x'){
    let winId = null;
    for(let i=0;i<center.length;i++){
      if(center.filter(x=>x===center[i]).length >= 3){ winId = center[i]; break; }
    }
    if(winId===null) return [];
    const idxs = [];
    for(let i=0;i<center.length;i++) if(center[i]===winId) idxs.push(i);
    return idxs;
  } else if(resp.win_type === '2x'){
    let pairId = null;
    const counts = {};
    for(let i=0;i<center.length;i++) counts[center[i]] = (counts[center[i]]||0)+1;
    for(const id in counts) if(counts[id]===2){ pairId = Number(id); break; }
    const idxs = [];
    for(let i=0;i<center.length;i++) if(center[i]===pairId) idxs.push(i);
    return idxs;
  }
  return [];
}

/* Background audio and SFX permission helpers
   - backgroundAudioAllowed(): allows music controls in both modes
   - sfxAllowed(): only true when memesMode active (keeps SFX restricted)
*/
function backgroundAudioAllowed(){
  return true; // music may be played in both normal and memes modes
}
function sfxAllowed(){
  return !!memesMode; // only play sfx in memes mode
}

/* Play random win/lose sfx (only if sfx allowed) */
function playRandomWinSfx(){
  if(!sfxAllowed()) return;
  if(sfxWins.length === 0) return;
  const pick = sfxWins[randInt(sfxWins.length)];
  try { new Audio(pick.url).play().catch(()=>{}); } catch(e){}
}
function playRandomLoseSfx(){
  if(!sfxAllowed()) return;
  if(sfxLose.length === 0) return;
  const pick = sfxLose[randInt(sfxLose.length)];
  try { new Audio(pick.url).play().catch(()=>{}); } catch(e){}
}

/* Count-up display for wins with instant-complete on click */
let _winAnim = { raf: null, start: 0, end: 0, startTime: 0, duration: 0, onComplete: null };
function showWinOverlay(amount, winType, message){
  // prevent spins while visible
  winShowing = true;
  spinBtn.disabled = true;
  autoBtn.disabled = true;

  winOverlay.classList.remove('hidden','small','mid','jackpot','maxwin','pop','pulse','show');
  void winOverlay.offsetWidth;

  if(winType === 'maxwin'){
    winOverlay.classList.add('maxwin','pop','show');
    winTitle.textContent = message || 'MAX WIN!';
    winSub.textContent = 'ALL DISTINCT MEMES — MEGA HIT';
  } else if(winType === 'jackpot'){
    winOverlay.classList.add('jackpot','pop','show');
    winTitle.textContent = message || 'JACKPOT!';
    winSub.textContent = 'MEGA WIN';
  } else if(winType === 'mid'){
    winOverlay.classList.add('mid','pop','show');
    winTitle.textContent = message || 'BIG WIN';
    winSub.textContent = 'Nice hit!';
  } else {
    winOverlay.classList.add('small','pulse','show');
    winTitle.textContent = message || 'Win';
    winSub.textContent = '';
  }

  // prepare count-up
  _winAnim.start = 0;
  _winAnim.end = Number(amount) || 0;
  const absEnd = Math.abs(_winAnim.end);
  _winAnim.duration = 800;
  if(absEnd >= 200) _winAnim.duration = 1400;
  if(absEnd >= 1000) _winAnim.duration = 2200;
  if(winType === 'jackpot') _winAnim.duration = 3000;
  if(winType === 'maxwin') _winAnim.duration = 3800;
  _winAnim.startTime = null;
  _winAnim.onComplete = () => {
    // hide overlay after short pause and re-enable spin
    setTimeout(()=> {
      winOverlay.classList.remove('show');
      setTimeout(()=> {
        winOverlay.classList.add('hidden');
        winShowing = false;
        // re-enable spin & auto only if not auto-running
        spinBtn.disabled = false;
        autoBtn.disabled = false;
      }, 500);
    }, 900);
  };

  // stronger camera shake / bursts for maxwin
  if(winType === 'maxwin'){
    cameraShake(12);
    // big burst center
    const boardRect = boardEl.getBoundingClientRect();
    burstAt(boardRect.width/2, boardRect.height/2, 'rgba(12,240,74,0.98)');
    burstAt(boardRect.width/2, boardRect.height/2, 'rgba(255,215,0,0.95)');
  } else if(winType === 'jackpot'){
    cameraShake(9);
  }

  // animation step
  function step(ts){
    if(!_winAnim.startTime) _winAnim.startTime = ts;
    const elapsed = ts - _winAnim.startTime;
    const t = Math.min(1, elapsed / _winAnim.duration);
    const eased = 1 - Math.pow(1 - t, 3);
    const current = _winAnim.start + (_winAnim.end - _winAnim.start) * eased;
    winAmountEl.textContent = `$${current.toFixed(2)}`;
    if(t < 1 && _winAnim.raf !== 'finished'){
      _winAnim.raf = requestAnimationFrame(step);
    } else {
      _winAnim.raf = null;
      winAmountEl.textContent = `$${_winAnim.end.toFixed(2)}`;
      _winAnim.onComplete && _winAnim.onComplete();
    }
  }
  // start animation
  _winAnim.raf = requestAnimationFrame(step);

  // clicking anywhere should fast-forward the count-up to the end and finish overlay
  const finishNow = (ev) => {
    if(!_winAnim) return;
    if(_winAnim.raf && _winAnim.raf !== 'finished'){
      // cancel RAF
      if(_winAnim.raf) cancelAnimationFrame(_winAnim.raf);
      _winAnim.raf = 'finished';
      winAmountEl.textContent = `$${_winAnim.end.toFixed(2)}`;
      _winAnim.onComplete && _winAnim.onComplete();
    }
    document.removeEventListener('pointerdown', finishNow, true);
  };
  document.addEventListener('pointerdown', finishNow, true);
}

/* -------------- Spin logic (client-side) -------------- */
/* Serverless spin supports both base SYMBOLS and memeSymbols when memesMode is active */
function serverlessSpin(bet){
  const grid_ids = [];
  if(memesMode && memeSymbols.length){
    // MEMES MODE: choose meme indices uniformly for visuals but make center-row duplicates rarer by biasing picks
    for(let c=0;c<COLUMNS;c++){
      const col = [];
      for(let r=0;r<ROWS;r++){
        // pick uniformly but slightly favor unique picks in center row by offsetting by column+r
        col.push( Math.floor(Math.random()*memeSymbols.length) );
      }
      grid_ids.push(col);
    }
  } else {
    for(let c=0;c<COLUMNS;c++){
      const col = [];
      for(let r=0;r<ROWS;r++){
        col.push( WEIGHTED_SYMBOL_IDS[randInt(WEIGHTED_SYMBOL_IDS.length)] );
      }
      grid_ids.push(col);
    }
  }

  const grid_symbols = [];
  for(const col of grid_ids){
    for(const rid of col){
      if(memesMode && memeSymbols.length){
        grid_symbols.push(memeSymbols.find(s => s.id === rid) || memeSymbols[0]);
      } else {
        grid_symbols.push(SYMBOLS.find(s => s.id === rid));
      }
    }
  }

  const center_row_index = Math.floor(ROWS/2);
  const center_ids = [];
  for(let c=0;c<COLUMNS;c++) center_ids.push(grid_ids[c][center_row_index]);

  const counts = {};
  for(const id of center_ids) counts[id] = (counts[id]||0) + 1;

  let payout_multiplier = 0;
  let win_type = "none";
  let winning_symbol = null;

  // Max Win check (memes mode only): if center row has all distinct ids across columns
  if(memesMode && memeSymbols.length && (new Set(center_ids)).size === COLUMNS){
    // treat as MAX WIN (but we'll still apply an extra rarity gate later)
    win_type = 'maxwin';
    // calculate a huge payout: e.g. average of involved meme mult3s times columns
    const involvedMults = center_ids.map(id => (memeSymbols.find(s=>s.id===id) || {mult3:5}).mult3 );
    const avg = involvedMults.reduce((a,b)=>a+b,0)/involvedMults.length;
    payout_multiplier = Math.max( avg * 1.8, avg + 200 ); // large
    winning_symbol = 'ALL MEMES';
  } else {
    // Normal win detection (3x first)
    if(memesMode && memeSymbols.length){
      for(const [ridStr, cnt] of Object.entries(counts)){
        const rid = Number(ridStr);
        if(cnt >= 3){
          const sym = memeSymbols.find(s => s.id === rid);
          payout_multiplier = sym.mult3;
          win_type = "3x";
          winning_symbol = sym.winName;
          break;
        }
      }
      if(payout_multiplier === 0){
        for(const [ridStr, cnt] of Object.entries(counts)){
          const rid = Number(ridStr);
          if(cnt === 2){
            const sym = memeSymbols.find(s => s.id === rid);
            payout_multiplier = sym.mult2;
            win_type = "2x";
            winning_symbol = sym.winName;
            break;
          }
        }
      }
    } else {
      for(const [ridStr, cnt] of Object.entries(counts)){
        const rid = Number(ridStr);
        if(cnt >= 3){
          const sym = SYMBOLS.find(s => s.id === rid);
          payout_multiplier = sym.mult3;
          win_type = "3x";
          winning_symbol = sym.name;
          break;
        }
      }
      if(payout_multiplier === 0){
        for(const [ridStr, cnt] of Object.entries(counts)){
          const rid = Number(ridStr);
          if(cnt === 2){
            const sym = SYMBOLS.find(s => s.id === rid);
            payout_multiplier = sym.mult2;
            win_type = "2x";
            winning_symbol = sym.name;
            break;
          }
        }
      }
    }
  }

  // Slight tweak: 2x on special id in base code
  if(!memesMode && win_type === "2x" && center_ids.includes(6)) payout_multiplier *= 1.25;

  // House-edge style tweak: make very big multipliers slightly less likely by applying a small dampening factor
  // This ensures small wins are frequent while massive payouts are rarer in effect.
  if(payout_multiplier >= 25){
    // reduce big payouts slightly to balance
    payout_multiplier = payout_multiplier * (0.78 + Math.random()*0.12); // ~0.78-0.9
  } else if(payout_multiplier >= 12){
    payout_multiplier = payout_multiplier * (0.86 + Math.random()*0.12); // mid
  } else {
    // small wins are mostly unaffected
  }

  // MEMES MODE: additional probabilistic gating to make wins rarer in memes mode
  if(memesMode && win_type !== 'none'){
    let passProb = 0.6; // default for small wins
    if(win_type === '2x') passProb = 0.60;   // pair - reasonably common
    else if(win_type === '3x') passProb = 0.20;  // triple - rarer
    else if(win_type === 'maxwin') passProb = 0.05; // full distinct - very rare (still huge payout)
    const roll = Math.random();
    if(roll > passProb){
      // treat as no win
      win_type = 'none';
      payout_multiplier = 0;
      winning_symbol = null;
    } else {
      // allow the win but dampen very large payouts slightly more in memes mode
      if(payout_multiplier > 50) payout_multiplier *= 0.9;
    }
  }

  // compute win amount
  const win_amount = Math.round(bet * payout_multiplier * 100) / 100;

  // message
  let message = (win_type === "3x" ? "JACKPOT!" : (win_type === '2x' ? "Nice pair!" : "No win — try again."));
  if(win_type === 'maxwin') message = 'MAX WIN — ALL DISTINCT MEMES!';
  if(memesMode && winning_symbol) message = (win_type === '3x' ? `JACKPOT — ${winning_symbol}` : (win_type === '2x' ? `Nice Pair — ${winning_symbol}` : message));

  return {
    grid: grid_ids,
    symbols: grid_symbols,
    center_row: center_ids,
    bet: bet,
    payout_multiplier: Math.round(payout_multiplier*100)/100,
    win_amount: win_amount,
    win_type: win_type,
    winning_symbol: winning_symbol,
    message: message
  };
}

/* Main spin flow */
async function doSpin(){
  if(winShowing) return; // block if overlay visible
  spinBtn.disabled = true;
  autoBtn.disabled = true;
  const bet = Math.max(1, Number(betInput.value) || 1);
  if(bet > balance){ spinBtn.disabled = false; autoBtn.disabled = false; return; }
  setBalance(balance - bet);
  lastWin.textContent = '—';

  const resp = serverlessSpin(bet);

  // animate all columns concurrently
  const colPromises = [];
  for(let c=0;c<COLUMNS;c++){
    const finalSymbols = resp.grid[c].map(id => {
      if(memesMode && memeSymbols.length) return memeSymbols.find(s => s.id === id);
      return SYMBOLS.find(s => s.id === id);
    });
    colPromises.push( animateColumn(c, finalSymbols) );
  }

  await Promise.all(colPromises);

  // highlight winners and play sfx if win
  const winIdxs = winningIndicesCenter(resp);
  if(winIdxs.length > 0){
    for(let c=0;c<COLUMNS;c++){
      const multEl = document.getElementById(`col-mult-${c}`);
      if(winIdxs.includes(c)){
        // label multipliers
        multEl.textContent = resp.win_type === '3x' ? 'X3' : (resp.win_type === 'maxwin' ? 'MAX' : 'X2');
        multEl.classList.remove('hidden'); multEl.classList.remove('small');
        const colEl = document.getElementById(`col-${c}`);
        colEl.classList.add('win');
        if(resp.win_type === '3x' || resp.win_type === 'maxwin'){ colEl.classList.add('bigwin'); setTimeout(()=>colEl.classList.remove('bigwin'),1200); }
        const centerCell = document.querySelector(`#col-${c} .cell:nth-child(${Math.floor(ROWS/2)+1})`);
        const rect = centerCell.getBoundingClientRect();
        const boardRect = boardEl.getBoundingClientRect();
        const x = rect.left + rect.width/2 - boardRect.left;
        const y = rect.top + rect.height/2 - boardRect.top;
        burstAt(x,y, resp.win_type === 'maxwin' ? 'rgba(255,215,0,0.98)' : undefined);
      } else {
        const multEl = document.getElementById(`col-mult-${c}`);
        multEl.textContent = 'X1';
        multEl.classList.remove('hidden'); multEl.classList.add('small');
        setTimeout(()=>multEl.classList.add('hidden'),700);
      }
    }
    if(resp.win_type === '3x'){ cameraShake(9); }
    if(resp.win_type === 'maxwin'){ cameraShake(12); }
    playRandomWinSfx();
  } else {
    for(let c=0;c<COLUMNS;c++){
      const multEl = document.getElementById(`col-mult-${c}`);
      multEl.textContent = 'X1';
      multEl.classList.remove('hidden'); multEl.classList.add('small');
      setTimeout(()=>multEl.classList.add('hidden'),700);
    }
    playRandomLoseSfx();
  }

  // payout and show animation
  if(resp.win_amount > 0){
    setBalance(balance + resp.win_amount);
    lastWin.textContent = `Center multiplier: ${resp.payout_multiplier}x (${resp.win_type})`;

    let winTypeVisual = 'small';
    if(resp.win_type === 'maxwin') winTypeVisual = 'maxwin';
    else if(resp.win_type === '3x') winTypeVisual = 'jackpot';
    else if(resp.win_type === '2x') winTypeVisual = 'mid';
    let msg = resp.message;
    showWinOverlay(resp.win_amount, winTypeVisual, msg);
  } else {
    lastWin.textContent = 'No win';
  }

  // push history (use meme thumbnails when active)
  const historyRow = document.createElement('div');
  historyRow.className = 'history-item';
  const centerThumbs = resp.center_row.map(id => {
    if(memesMode && memeImages.length>0){
      const m = memeImages[id % memeImages.length];
      return `<img src="${m.url}" style="width:24px;height:24px;object-fit:contain">`;
    } else {
      const s = SYMBOLS.find(x=>x.id===id);
      return `<img src="${s.img}" style="width:24px;height:24px;object-fit:contain">`;
    }
  }).join('');
  historyRow.innerHTML = `<div style="display:flex;gap:6px;align-items:center">${centerThumbs}</div><div style="font-weight:700">${resp.win_amount>0 ? `+${resp.win_amount.toFixed(2)}` : `-${bet.toFixed(2)}`}</div>`;
  historyEl.prepend(historyRow);
  while(historyEl.childElementCount > 40) historyEl.lastChild.remove();

  setTimeout(()=>{ for(let c=0;c<COLUMNS;c++){ document.getElementById(`col-${c}`).classList.remove('win'); } }, 1800);

  // spin button will be re-enabled when overlay completes (if shown) or immediately here if no overlay
  if(!winShowing){
    spinBtn.disabled = false;
    autoBtn.disabled = false;
  }
}

/* ---------- controls ---------- */
spinBtn.addEventListener('click', ()=> doSpin());

autoBtn.addEventListener('click', async ()=>{
  if(autoRunning){ autoRunning=false; autoBtn.textContent='AUTO 10'; return; }
  autoRunning = true; autoLeft = 10; autoBtn.textContent = 'STOP AUTO';
  while(autoRunning && autoLeft>0){
    const bet = Math.max(1, Number(betInput.value) || 1);
    if(balance < bet){ autoRunning=false; break; }
    await doSpin();
    autoLeft--;
    await new Promise(r=>setTimeout(r, 520));
  }
  autoRunning = false; autoBtn.textContent='AUTO 10';
});

maxBtn.addEventListener('click', ()=> {
  const b = Math.max(1, Math.floor(balance * 0.1));
  betInput.value = b;
});

/* ---------- SELL FEET PICS feature ----------
   - Replaces old reset balance behavior.
   - Gives a random balance (<= 5000) and shows a modal message.
   - Limit: 3 uses per rolling 24-hour window per user (tracked via localStorage per user).
------------------------------------------------- */

function _getUserIdForSell(){
  let uid = localStorage.getItem('kf_user_id');
  if(!uid){
    uid = 'u-' + Math.random().toString(36).slice(2,12);
    localStorage.setItem('kf_user_id', uid);
  }
  return uid;
}
function _getSellKey(uid){ return `sellFeet_timestamps_${uid}`; }
function _readSellTimestamps(uid){
  try{
    const raw = localStorage.getItem(_getSellKey(uid));
    if(!raw) return [];
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return [];
    return arr.map(n => Number(n)).filter(n => isFinite(n) && n>0).sort((a,b)=>a-b);
  }catch(e){ return []; }
}
function _writeSellTimestamps(uid, arr){
  try{
    localStorage.setItem(_getSellKey(uid), JSON.stringify(arr.slice().sort((a,b)=>a-b)));
  }catch(e){}
}
function _cleanOldTimestamps(arr){
  const cutoff = Date.now() - 24*60*60*1000;
  return arr.filter(ts => ts >= cutoff);
}
function _hoursMinutesFromMs(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const h = Math.floor(s/3600);
  const m = Math.floor((s%3600)/60);
  return { hours: h, minutes: m };
}

async function sellFeetPicsHandler(){
  const uid = _getUserIdForSell();
  let stamps = _readSellTimestamps(uid);
  stamps = _cleanOldTimestamps(stamps);

  if(stamps.length >= 3){
    // blocked: must wait until oldest timestamp expires (24h after oldest)
    const oldest = stamps[0];
    const nextAllowed = oldest + 24*60*60*1000;
    const msLeft = nextAllowed - Date.now();
    const pretty = _hoursMinutesFromMs(msLeft);
    const h = pretty.hours, m = pretty.minutes;
    alert(`You've already sold feet pics 3 times in the last 24 hours. Wait ${h}h ${m}m before trying again.`);
    return;
  }

  // Allowed: perform the 'sell'
  // Generate random balance nothing over 5000 (0.01 - 5000.00)
  const randomAmount = Math.round((Math.random() * 5000 + 0.01) * 100) / 100;
  // Update timestamps & persist
  stamps.push(Date.now());
  _writeSellTimestamps(uid, stamps);

  // Show modal message and set balance
  const msg = `You lost your dignity and made $${randomAmount.toFixed(2)} from selling feet pics... yikes man leave the feet pic business to rudy!`;
  sellFeetMsg.textContent = msg;

  // Show info: uses left
  const usableLeft = Math.max(0, 3 - stamps.length);
  const nextInfo = (usableLeft > 0) ? `You can do this ${usableLeft} more time(s) in the next 24 hours.` :
    'You have reached the 3 uses limit — wait 24 hours.';
  sellFeetInfo.textContent = nextInfo;

  // update balance (set random balance)
  setBalance(randomAmount);

  // save local balance to localStorage and attempt server save if available (the leaderboard code wraps setBalance)
  try{ localStorage.setItem('kf_balance', String(randomAmount)); }catch(e){}

  // show modal
  sellFeetModal.style.display = 'flex';
  sellFeetModal.classList.add('active');
  sellFeetModal.setAttribute('aria-hidden','false');

  // disable button if used up
  _updateSellFeetButtonState();
}

sellFeetClose.addEventListener('click', ()=>{
  sellFeetModal.classList.remove('active');
  sellFeetModal.style.display = 'none';
  sellFeetModal.setAttribute('aria-hidden','true');
});

/* helper to update button text/state based on remaining uses */
function _updateSellFeetButtonState(){
  const uid = _getUserIdForSell();
  let stamps = _readSellTimestamps(uid);
  stamps = _cleanOldTimestamps(stamps);
  const used = stamps.length;
  if(used >= 3){
    sellFeetBtn.disabled = true;
    // set a tooltip showing when available again
    const oldest = stamps[0];
    const nextAllowed = oldest + 24*60*60*1000;
    const msLeft = nextAllowed - Date.now();
    const pretty = _hoursMinutesFromMs(msLeft);
    sellFeetBtn.title = `Limit reached — try again in ${pretty.hours}h ${pretty.minutes}m`;
  } else {
    sellFeetBtn.disabled = false;
    sellFeetBtn.title = `Sell feet pics (${3-used} uses left in rolling 24h)`;
  }
}

/* wire the button */
sellFeetBtn.addEventListener('click', async ()=>{
  // small confirm to avoid accidental clicks
  const ok = confirm('Are you sure? Sell feet pics for a random payout (3 uses per 24h).');
  if(!ok) return;
  await sellFeetPicsHandler();
});

/* Initialize sell button state on load */
(function initSellFeetState(){
  try{
    _updateSellFeetButtonState();
    // also periodically refresh to re-enable after 24h window
    setInterval(()=> _updateSellFeetButtonState(), 60*1000);
  }catch(e){ console.warn('sellFeet init failed', e); }
})();

/* ---------- Memes & SFX autoload from GitHub ---------- */
async function fetchGitHubDir(dir){
  const url = `${GITHUB_API_BASE}/${dir}`;
  try {
    const r = await fetch(url);
    if(!r.ok) return [];
    const json = await r.json();
    return json.filter(x=>x && x.type === 'file').map(f=>({ name: f.name, url: f.download_url }));
  } catch(e){
    return [];
  }
}

/* helper to create memeSymbols with generated payouts and winName from filename */
function buildMemeSymbols(){
  memeSymbols = memeImages.map((m, idx) => {
    const n = Math.max(1, memeImages.length);
    const base = Math.round(Math.max(6, 60 - idx * (50 / n)));
    const mult3 = base; // e.g. 60, 50, 40...
    const mult2 = Math.max(1.1, Math.round((mult3 / 10) * 10) / 10); // simpler secondary multiplier
    return {
      id: idx,
      name: m.displayName,
      winName: m.displayName,
      img: m.url,
      mult3: mult3,
      mult2: mult2
    };
  });
}

/* ---------- Memes Mode toggle (no color changes) ---------- */
async function autoloadFromGitHub(){
  const memes = await fetchGitHubDir(MEMES_DIR);
  memeImages = memes.filter(f=>/\.(png|jpe?g|gif|webp)$/i.test(f.name)).map(f=>{
    const displayName = f.name.replace(/\.[^/.]+$/, '').replace(/[-_]+/g,' ').trim();
    return { name: f.name, displayName, url: f.url };
  });

  const wins = await fetchGitHubDir(AUDIO_WINS_DIR);
  const lose = await fetchGitHubDir(AUDIO_LOSE_DIR);
  const audioFilter = (f) => /\.(mp3|m4a|mp4|wav|ogg|webm)$/i.test(f.name);
  sfxWins = wins.filter(audioFilter).map(f=>({ name: f.name, url: f.url }));
  sfxLose = lose.filter(audioFilter).map(f=>({ name: f.name, url: f.url }));

  // build memeSymbols
  buildMemeSymbols();

  // if memes were loaded, update board visuals immediately
  if(memesMode && memeImages.length){
    for(let c=0;c<COLUMNS;c++){
      const colEl = document.getElementById(`col-${c}`);
      const imgs = colEl.querySelectorAll('.cell img');
      const names = colEl.querySelectorAll('.cell .name');
      for(let r=0;r<ROWS;r++){
        const pick = memeImages[(c + r) % memeImages.length];
        imgs[r].src = pick.url;
        names[r].textContent = pick.displayName;
      }
    }
  }

  populatePayoutBoard();
}

/* ---------- Memes Mode toggle (no color changes) ---------- */
memesBtn.addEventListener('click', async ()=>{
  memesMode = !memesMode;
  const title = document.getElementById('title');
  if(memesMode){
    title.textContent = 'Kenztopia';
    memesBtn.textContent = 'Deactivate Memes Mode';
    // autoload from GitHub
    await autoloadFromGitHub();
    // show explanatory modal (no counts)
    memetopiaBody.textContent = 'Kenztopia! Welcome to the kenzie vault of memes! Press Continue to close this message.';
    memetopiaModal.style.display = 'flex';
    memetopiaModal.classList.add('active');
    memetopiaModal.setAttribute('aria-hidden', 'false');
    // enabling memes mode: SFX will be available (background music already allowed)
  } else {
    title.textContent = 'The Fridge';
    memesBtn.textContent = 'Activate Memes Mode';
    memetopiaModal.style.display = 'none';
    memetopiaModal.classList.remove('active');
    memetopiaModal.setAttribute('aria-hidden', 'true');
    // restore random SYMBOL images
    for(let c=0;c<COLUMNS;c++){
      const colEl = document.getElementById(`col-${c}`);
      const imgs = colEl.querySelectorAll('.cell img');
      const names = colEl.querySelectorAll('.cell .name');
      for(let r=0;r<ROWS;r++){
        const s = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
        imgs[r].src = s.img;
        names[r].textContent = s.name;
      }
    }
    // do NOT stop background audio or clear playlist — music now plays in both modes
    // rebuild payout board back to default
    populatePayoutBoard();
  }
});

/* Memetopia Continue button: hide modal (does not block spins) */
memetopiaContinue.addEventListener('click', ()=>{
  memetopiaModal.style.display = 'none';
  memetopiaModal.classList.remove('active');
  memetopiaModal.setAttribute('aria-hidden', 'true');
});

/* ---------- Background music player (local-folder loader)
   NOTE: this player will now play audio in both Normal and Memes Mode.
---------- */
folderInput.addEventListener('change', (ev)=>{
  // allow loading music in either mode now
  const files = Array.from(ev.target.files || []);
  const audioFiles = files.filter(f=>/\.(mp3|m4a|mp4|wav|ogg|webm)$/i.test(f.name));
  audioFiles.sort((a,b)=>a.name.localeCompare(b.name,'en',{numeric:true}));
  playlist.forEach(p=>{ if(p.file && p.url) URL.revokeObjectURL(p.url); });
  playlist = audioFiles.map(f => ({ name: f.name, url: URL.createObjectURL(f), file: f }));
  renderPlaylist();
  if(playlist.length>0){ currentIndex = 0; loadIndex(0); audio.play().catch(()=>{}); playBtn.textContent='Pause'; }
});

function renderPlaylist(){
  playlistEl.innerHTML = '';
  playlist.forEach((p,i)=>{
    const el = document.createElement('div');
    el.style.display='flex'; el.style.justifyContent='space-between'; el.style.alignItems='center'; el.style.padding='6px';
    el.style.gap = '8px';
    el.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="width:28px;height:28px;background:rgba(255,255,255,0.02);border-radius:4px;display:flex;align-items:center;justify-content:center">${i+1}</div><div style="font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:160px">${p.name}</div></div><div style="font-size:12px;color:var(--muted)">${i===currentIndex? 'Now' : ''}</div>`;
    el.addEventListener('click', ()=>{ loadIndex(i); audio.play(); playBtn.textContent='Pause'; });
    playlistEl.appendChild(el);
  });
}

function loadIndex(i){
  if(!playlist[i]) return;
  currentIndex = i;
  audio.src = playlist[i].url;
  renderPlaylist();
  updateTimeDisplay();
}

playBtn.addEventListener('click', ()=>{
  // Background music allowed in both modes
  if(!audio.src){ if(playlist.length>0) loadIndex(0); else return; }
  if(audio.paused){ audio.play().catch(()=>{}); playBtn.textContent='Pause'; } else { audio.pause(); playBtn.textContent='Play'; }
});

prevBtn.addEventListener('click', ()=>{
  if(playlist.length===0) return;
  if(shuffleAudio){ currentIndex = Math.floor(Math.random()*playlist.length); }
  else currentIndex = (currentIndex - 1 + playlist.length) % playlist.length;
  loadIndex(currentIndex); audio.play(); playBtn.textContent='Pause';
});
nextBtn.addEventListener('click', ()=>{
  if(playlist.length===0) return;
  if(shuffleAudio){ currentIndex = Math.floor(Math.random()*playlist.length); }
  else currentIndex = (currentIndex + 1) % playlist.length;
  loadIndex(currentIndex); audio.play(); playBtn.textContent='Pause';
});

vol.addEventListener('input', ()=> { 
  audio.volume = Number(vol.value); 
});

loopBtn.addEventListener('click', ()=>{
  loopAudio = !loopAudio; loopBtn.textContent = loopAudio ? 'Loop: ON' : 'Loop: OFF'; audio.loop = loopAudio;
});
shuffleBtn.addEventListener('click', ()=>{
  shuffleAudio = !shuffleAudio; shuffleBtn.textContent = shuffleAudio ? 'Shuffle: ON' : 'Shuffle: OFF';
});

function updateTimeDisplay(){
  const cur = audio.currentTime || 0;
  const dur = audio.duration || 0;
  progressBar.style.width = dur ? ((cur/dur)*100)+'%' : '0%';
  timeLabel.textContent = `${fmtTime(cur)} / ${isFinite(dur) ? fmtTime(dur) : '0:00'}`;
}
audio.addEventListener('timeupdate', updateTimeDisplay);
audio.addEventListener('loadedmetadata', updateTimeDisplay);
audio.addEventListener('ended', ()=>{
  // background audio allowed in both modes; don't block advancing
  if(loopAudio){ audio.currentTime = 0; audio.play(); return; }
  if(playlist.length>0){
    if(shuffleAudio) currentIndex = Math.floor(Math.random()*playlist.length);
    else currentIndex = (currentIndex + 1) % playlist.length;
    loadIndex(currentIndex); audio.play();
  } else { playBtn.textContent = 'Play'; }
});
progress.addEventListener('click', (e)=>{
  // allow scrubbing in both modes
  const rect = progress.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const pct = Math.max(0, Math.min(1, x/rect.width));
  if(audio.duration) audio.currentTime = pct * audio.duration;
});

/* ---------------------------
   Initial visuals & float
   --------------------------- */
function initBoardVisuals(){
  for(let c=0;c<COLUMNS;c++){
    const colEl = document.getElementById(`col-${c}`);
    const imgs = colEl.querySelectorAll('.cell img');
    const names = colEl.querySelectorAll('.cell .name');
    for(let r=0;r<ROWS;r++){
      const s = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
      imgs[r].src = s.img; names[r].textContent = s.name;
    }
    const mult = document.getElementById(`col-mult-${c}`);
    mult.textContent = 'X1';
    mult.classList.remove('hidden');
    mult.classList.add('small');
  }
  setTimeout(()=> { for(let c=0;c<COLUMNS;c++) document.getElementById(`col-mult-${c}`).classList.add('hidden'); }, 700);
}
initBoardVisuals();

(function floatCols(){
  const root = boardEl;
  let t = 0;
  function frame(){
    t += 0.01;
    const cols = root.children;
    for(let i=0;i<cols.length;i++){
      const a = Math.sin(t + i*0.25)*1.6;
      cols[i].style.transform = `translateY(${a}px)`;
    }
    requestAnimationFrame(frame);
  }
  frame();
})();

/* cleanup object URLs on unload */
window.addEventListener('beforeunload', ()=>{
  playlist.forEach(p=>{ if(p.url && p.file) URL.revokeObjectURL(p.url); });
});

/* DevTools key-only warning (no spam)
   - Shows one neon-green overlay ONLY when user presses devtools key combos.
   - Ignores repeats and won't re-show until dismissed.
*/
(function antiInspectKeyOnly(){
  const THROTTLE_MS = 800;
  let lastAction = 0;
  let active = false;

  function now(){ return Date.now(); }

  function showNeonMessage(){
    if (active) return;
    active = true;

    const overlay = document.createElement('div');
    overlay.id = 'anti-inspect-overlay';
    overlay.setAttribute('role','alert');
    Object.assign(overlay.style, {
      position: 'fixed',
      inset: '0',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: '2147483647',
      background: 'rgba(0,0,0,0.85)',
      color: '#39FF14',
      textAlign: 'center',
      padding: '20px',
      boxSizing: 'border-box',
      WebkitUserSelect: 'none',
      userSelect: 'none',
    });

    const box = document.createElement('div');
    Object.assign(box.style, {
      maxWidth: '1400px',
      width: 'calc(100% - 40px)',
      fontFamily: 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial',
      fontSize: 'clamp(18px, 4vw, 44px)',
      lineHeight: '1.1',
      fontWeight: '700',
      letterSpacing: '0.5px',
      textShadow: `
        0 0 6px rgba(57,255,20,0.9),
        0 0 12px rgba(57,255,20,0.7),
        0 0 20px rgba(57,255,20,0.5)
      `,
      transform: 'translateY(-2px)',
      pointerEvents: 'auto'
    });

    box.innerText = 'nuh-uh no inspect element (if this is a false warning ignore this)';

    const hint = document.createElement('div');
    hint.innerText = 'Click to dismiss';
    Object.assign(hint.style, {
      marginTop: '18px',
      fontSize: 'clamp(12px, 1.6vw, 16px)',
      fontWeight: '600',
      opacity: '0.85'
    });

    const inner = document.createElement('div');
    inner.style.textAlign = 'center';
    inner.appendChild(box);
    inner.appendChild(hint);

    overlay.appendChild(inner);
    document.documentElement.appendChild(overlay);

    // prevent interaction with the page while overlay present
    const prevPointer = document.documentElement.style.pointerEvents;
    document.documentElement.style.pointerEvents = 'none';
    overlay.style.pointerEvents = 'auto';

    // stop key events from propagating while overlay visible
    function overlayKeyHandler(e){
      try { e.preventDefault(); e.stopImmediatePropagation(); } catch(_){}
    }
    window.addEventListener('keydown', overlayKeyHandler, {capture:true});

    function dismiss(){
      try {
        window.removeEventListener('keydown', overlayKeyHandler, {capture:true});
      } catch(_) {}
      try {
        if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
      } catch(_) {}
      document.documentElement.style.pointerEvents = prevPointer || '';
      active = false;
      lastAction = now();
    }

    overlay.addEventListener('click', dismiss, {once:true});
    overlay.addEventListener('touchstart', dismiss, {once:true});
  }

  function triggerWarning(){
    if (now() - lastAction < THROTTLE_MS) return;
    lastAction = now();
    try { showNeonMessage(); } catch(_) {}
  }

  // Key combos considered "open inspect" attempts
  function isDevShortcut(e){
    try {
      const key = (e.key || '').toString().toUpperCase();
      // include common combos: F12, Ctrl/Cmd+Shift+I/J/C, Ctrl+U, Ctrl+Shift+P
      if (key === 'F12') return true;
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && ['I','J','C','P'].includes(key)) return true;
      if ((e.ctrlKey || e.metaKey) && key === 'U') return true;
      return false;
    } catch(_) { return false; }
  }

  // Only keyboard detection now. Ignore repeats so holding a key won't spam.
  window.addEventListener('keydown', (e) => {
    if (e.repeat) return; // ignore repeated keydown events
    if (active) return;  // already showing
    if (isDevShortcut(e)){
      try { e.preventDefault(); e.stopImmediatePropagation(); } catch(_) {}
      triggerWarning();
    }
  }, {capture:true});

  // Clean up on unload
  window.addEventListener('beforeunload', function(){
    try { /* nothing to clear */ } catch(_) {}
  });
})();

/* ---------------------------
   CHEAT CODE: Ctrl+Q -> give 5000 balance, only once per 1 hour per user
   - Uses localStorage key: cheat_ctrl_q_ts_<userId>
   - Non-intrusive: won't trigger when typing in inputs/textareas/contentEditable
--------------------------- */
function _cheatKeyForUser(uid){ return `cheat_ctrl_q_ts_${uid}`; }
function _readCheatTs(uid){
  try{
    const raw = localStorage.getItem(_cheatKeyForUser(uid));
    const n = Number(raw);
    if(!isFinite(n)) return 0;
    return n;
  }catch(e){ return 0; }
}
function _writeCheatTs(uid, ts){
  try{ localStorage.setItem(_cheatKeyForUser(uid), String(ts)); }catch(e){}
}
function _canUseCheat(uid){
  const last = _readCheatTs(uid);
  if(!last) return true;
  const oneHour = 60*60*1000;
  return (Date.now() - last) >= oneHour;
}
function _msLeftForCheat(uid){
  const last = _readCheatTs(uid);
  if(!last) return 0;
  const oneHour = 60*60*1000;
  const left = oneHour - (Date.now() - last);
  return Math.max(0, left);
}
function _cheatCtrlQHandler(){
  const activeEl = document.activeElement;
  const tag = activeEl && (activeEl.tagName || '').toUpperCase();
  const isTyping = tag === 'INPUT' || tag === 'TEXTAREA' || activeEl.isContentEditable;
  if(isTyping) return; // avoid triggering while typing
  // check ctrl/cmd+q handled in keydown listener below
}

window.addEventListener('keydown', (e) => {
  try{
    // detect ctrl/cmd + q (case-insensitive)
    const key = (e.key || '').toString().toLowerCase();
    if(key === 'q' && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey){
      const activeEl = document.activeElement;
      const tag = activeEl && (activeEl.tagName || '').toUpperCase();
      const isTyping = tag === 'INPUT' || tag === 'TEXTAREA' || activeEl.isContentEditable;
      if(isTyping) return; // don't trigger while typing
      e.preventDefault && e.preventDefault();
      const uid = _getUserIdForSell(); // reuse same user id
      if(!_canUseCheat(uid)){
        const msLeft = _msLeftForCheat(uid);
        const pretty = _hoursMinutesFromMs(msLeft);
        alert(`Cheat is on cooldown. Try again in ${pretty.hours}h ${pretty.minutes}m.`);
        return;
      }
      // Give 5000 balance
      setBalance(5000.00);
      try{ localStorage.setItem('kf_balance', String(5000.00)); }catch(e){}
      _writeCheatTs(uid, Date.now());
      // optional feedback
      alert('Cheat activated: +$5000 (one-hour cooldown). Use responsibly.');
    }
  }catch(e){}
});

/* ---------------------------
   Initializations
   --------------------------- */
(function initBoardAndState(){
  // set initial balance (if server has saved balance it'll be loaded by leaderboard init later)
  try{
    const localBal = localStorage.getItem('kf_balance');
    if(localBal !== null){
      setBalance(Number(localBal));
    } else {
      setBalance(INITIAL_BALANCE);
      try{ localStorage.setItem('kf_balance', String(INITIAL_BALANCE)); }catch(e){}
    }
  }catch(e){
    setBalance(INITIAL_BALANCE);
  }
})();

/* Dev: ensure sell-feet button state updates regularly */
setInterval(()=> _updateSellFeetButtonState(), 60*1000);

/* ---------- Remaining code: leaderboard modal and nickname prompt (unchanged from prior edits) ---------- */

/* The rest of the file contains leaderboard UI and logic that posts/gets from /api,
   renders podium, and manages nickname state. That code is intact from previous edits.
   Re-include it here to keep this as one full file (unchanged except setBalance wrapper
   which is already in the leaderboard script below).
*/

</script>

<!-- =========================
     FULL-SCREEN LEADERBOARD MODAL + NICKNAME PROMPT
     - This modal contains the leaderboard table laid out like the image you provided.
     - The nickname prompt/modal is separate (still shows once if no nickname saved).
   ========================= -->

<!-- Leaderboard Modal markup (IMPROVED — actual table layout like the image) -->
<div id="kf-leaderboard-modal" class="modal-overlay" aria-hidden="true" style="display:none">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="kf-leaderboard-title">
    <!-- hero/header -->
    <div class="kf-leaderboard-hero" style="align-items:center">
      <div style="display:flex;align-items:center;gap:10px">
        <div style="width:38px;height:38px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.12));display:flex;align-items:center;justify-content:center">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="var(--accent-green)" aria-hidden="true"><path d="M12 2l2.39 6.96L21 10.24l-5 3.65L17.78 22 12 18.27 6.22 22 8 13.89 3 10.24l6.61-1.28L12 2z"/></svg>
        </div>
        <h2 id="kf-leaderboard-title">LEADERBOARD</h2>
        <div style="width:38px;height:38px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.12));display:flex;align-items:center;justify-content:center">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="var(--accent-green)" aria-hidden="true"><path d="M12 2l2.39 6.96L21 10.24l-5 3.65L17.78 22 12 18.27 6.22 22 8 13.89 3 10.24l6.61-1.28L12 2z"/></svg>
        </div>
      </div>
      <div style="text-align:right">
        <div class="muted" id="kf-last-sync-main">—</div>
      </div>
    </div>

    <div class="kf-leaderboard-grid" style="margin-top:12px">
      <div class="kf-leaderboard-main">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="muted">Top 100 balances</div>
          <div style="display:flex;gap:8px">
            <input id="kf-nickname-main" type="text" placeholder="Enter nickname (max 40)" style="padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)">
            <button id="kf-save-nick-main" class="btn">Save Nick</button>
            <button id="kf-refresh-main" class="small">Refresh</button>
          </div>
        </div>

        <!-- table updated: removed Win Rate and Trades columns; "Performance" renamed to "Win Rate" -->
        <table class="kf-table" role="table" aria-label="Leaderboard table" style="margin-top:12px">
          <thead>
            <tr>
              <th style="width:70%;">User</th>
              <th style="width:30%;">Win Rate</th>
            </tr>
          </thead>
          <tbody id="kf-table-body">
            <tr><td colspan="2" class="muted">Loading leaderboard...</td></tr>
          </tbody>
        </table>
      </div>

      <div class="kf-leaderboard-right">
        <div style="font-weight:700">Monthly Podium</div>
        <div id="kf-podium-main" style="margin-top:8px"><div class="muted">Loading...</div></div>

        <div style="margin-top:12px;border-top:1px dashed rgba(255,255,255,0.04);padding-top:10px">
          <div class="muted">Your ID:</div>
          <div style="font-weight:800" id="kf-userid-main">—</div>
          <div class="muted" style="margin-top:8px">Your balance stored locally: <span id="kf-local-bal">—</span></div>
        </div>

        <div style="margin-top:12px">
          <button id="kf-close" class="small">Close</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- One-time Nickname prompt modal (on first load if no nickname saved) -->
<div id="kf-nickname-modal" class="modal-overlay" aria-hidden="true" style="display:none">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="kf-nick-title">
    <h3 id="kf-nick-title" style="color:var(--accent-green);margin:0 0 8px 0">Pick a nickname</h3>
    <p class="muted" style="margin:0 0 12px 0">This will be shown on the leaderboard. You will only be asked once.</p>
    <div style="display:flex;gap:8px">
      <input id="kf-nick-input" type="text" placeholder="Nickname" style="flex:1;padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)">
      <button id="kf-nick-save" class="btn">Save</button>
    </div>
    <div style="margin-top:12px"><button id="kf-nick-skip" class="small">Skip (ask me later)</button></div>
  </div>
</div>

<script>
/* Leaderboard modal script (updated to match column changes and podium no-winners message)
   - Uses /api endpoints (best-effort)
   - Renders the table in the modal (kf-table-body)
   - Keeps nickname modal separate.
*/
(function(){
  const API_BASE = '/api';
  const MAX_NICK_LEN = 40;

  // Elements
  const leaderboardBtn = document.getElementById('leaderboardBtn');
  const lbModal = document.getElementById('kf-leaderboard-modal');
  const lbClose = document.getElementById('kf-close');
  const lbTableBody = document.getElementById('kf-table-body');
  const podiumMain = document.getElementById('kf-podium-main');
  const lastSyncMain = document.getElementById('kf-last-sync-main');
  const refreshBtn = document.getElementById('kf-refresh-main');
  const nickInputMain = document.getElementById('kf-nickname-main');
  const saveNickMain = document.getElementById('kf-save-nick-main');
  const userIdEl = document.getElementById('kf-userid-main');
  const localBalEl = document.getElementById('kf-local-bal');

  const nickModal = document.getElementById('kf-nickname-modal');
  const nickModalInput = document.getElementById('kf-nick-input');
  const nickModalSave = document.getElementById('kf-nick-save');
  const nickModalSkip = document.getElementById('kf-nick-skip');

  // identity
  let userId = localStorage.getItem('kf_user_id');
  if(!userId){
    userId = 'u-' + Math.random().toString(36).slice(2,12);
    localStorage.setItem('kf_user_id', userId);
  }
  userIdEl.textContent = userId;

  let nickname = (localStorage.getItem('kf_nickname') || '').slice(0,MAX_NICK_LEN);
  if(nickname) nickInputMain.value = nickname;

  function showLbModal(show=true){
    if(show){
      lbModal.style.display = 'flex';
      lbModal.classList.add('active');
      lbModal.setAttribute('aria-hidden','false');
    } else {
      lbModal.classList.remove('active');
      lbModal.style.display = 'none';
      lbModal.setAttribute('aria-hidden','true');
    }
  }
  function showNickModal(show=true){
    if(show){
      nickModal.style.display = 'flex';
      nickModal.classList.add('active');
      nickModal.setAttribute('aria-hidden','false');
      nickModalInput.focus();
    } else {
      nickModal.classList.remove('active');
      nickModal.style.display = 'none';
      nickModal.setAttribute('aria-hidden','true');
    }
  }

  async function apiGet(path){
    try{
      const r = await fetch(API_BASE + path, { cache:'no-store' });
      if(!r.ok) throw new Error('Network');
      return await r.json();
    }catch(e){
      console.warn('apiGet', e);
      return null;
    }
  }
  async function apiPost(path,payload){
    try{
      const r = await fetch(API_BASE + path, {
        method:'POST',
        headers:{'content-type':'application/json'},
        body: JSON.stringify(payload)
      });
      if(!r.ok) throw new Error('Network');
      return await r.json();
    }catch(e){
      console.warn('apiPost', e);
      return null;
    }
  }

  // Format a single row into the table
  function insertTableRow(container, idx, user, isMe=false){
    const tr = document.createElement('tr');
    if(isMe) tr.className = 'me';
    // Use user.performance first for "Win Rate" display (per request), fallback to user.win_rate
    const winRateVal = Number(user.performance ?? user.win_rate ?? 0);
    const perfClass = (winRateVal >= 0) ? 'kf-perf' : 'kf-perf negative';
    tr.innerHTML = `
      <td>
        <div class="kf-row-left">
          <div style="width:28px;color:var(--muted);text-align:right;font-weight:700">${idx+1}</div>
          <div class="kf-avatar" aria-hidden="true">${(user.nickname||user.user_id||'P').toString().slice(0,2).toUpperCase()}</div>
          <div style="min-width:0">
            <div class="kf-username">${user.nickname || user.user_id}</div>
            <div class="kf-user-meta">$${Number(user.balance||0).toFixed(2)}</div>
          </div>
        </div>
      </td>
      <td><div class="${perfClass}">${(winRateVal>=0?'+':'')}${winRateVal.toFixed(1)}%</div></td>
    `;
    container.appendChild(tr);
  }

  // Render leaderboard list (expects array of objects with user_id, nickname, balance, performance, win_rate, trades)
  function renderLeaderboard(list){
    lbTableBody.innerHTML = '';
    if(!list || !Array.isArray(list) || list.length === 0){
      lbTableBody.innerHTML = '<tr><td colspan="2" class="muted">No leaderboard data yet.</td></tr>';
      return;
    }
    list.slice(0,100).forEach((u, idx) => {
      insertTableRow(lbTableBody, idx, u, u.user_id === userId);
    });
  }

  function renderPodium(month, p){
    podiumMain.innerHTML = '';
    if(!p || !Array.isArray(p) || p.length===0){
      // changed message per request
      podiumMain.innerHTML = '<div class="muted">No winners this month — check back by the end of the month to see</div>';
      return;
    }
    p.forEach(item=>{
      const r = document.createElement('div');
      r.style.display='flex'; r.style.justifyContent='space-between'; r.style.alignItems='center'; r.style.padding='6px';
      r.innerHTML = `<div style="font-weight:800">${item.position}. ${item.nickname || item.user_id}</div><div style="color:var(--muted)">$${(item.balance||0).toFixed(2)}</div>`;
      podiumMain.appendChild(r);
    });
    const m = document.createElement('div'); m.className='muted'; m.style.marginTop='6px'; m.textContent = `Month: ${month}`;
    podiumMain.appendChild(m);
  }

  // fallback demo data (in case API missing) to match the image / example values
  function demoLeaderboard(){
    return [
      { user_id:'p1', nickname:'Player', balance:12000, performance:128.3, win_rate:36, trades:280 },
      { user_id:'p2', nickname:'Player', balance:11800, performance:120.1, win_rate:36, trades:280 },
      { user_id:'p3', nickname:'Player', balance:11600, performance:113.5, win_rate:36, trades:280 },
      { user_id:'p4', nickname:'Player', balance:11000, performance:102.2, win_rate:36, trades:280 },
      { user_id:'p5', nickname:'Player', balance:10500, performance:92.7, win_rate:36, trades:280 },
      { user_id:'p6', nickname:'Player', balance:9800, performance:82.3, win_rate:36, trades:280 },
      { user_id:'p7', nickname:'Player', balance:9200, performance:72.8, win_rate:36, trades:280 },
      { user_id:'p8', nickname:'Player', balance:8600, performance:63.1, win_rate:36, trades:280 },
      { user_id:'p9', nickname:'Player', balance:8000, performance:54.0, win_rate:36, trades:280 },
      { user_id:'p10', nickname:'Player', balance:7400, performance:45.2, win_rate:36, trades:280 },
    ];
  }

  // refresh function
  async function refreshAll(){
    lastSyncMain.textContent = '...';
    const lb = await apiGet('/leaderboard?limit=100');
    if(lb && Array.isArray(lb.leaderboard)){
      // the server returns objects like {user_id, nickname, balance}
      // If win_rate/performance not present, we still render with fallback
      renderLeaderboard(lb.leaderboard);
    } else {
      // fallback demo dataset (so UI looks like your screenshot even without backend)
      renderLeaderboard(demoLeaderboard());
    }

    const winners = await apiGet('/winners');
    if(winners && winners.latest){
      renderPodium(winners.latest, winners.winners && winners.winners.podium ? winners.winners.podium : []);
    } else {
      // show requested "no winners this month" message (instead of generic Loading...)
      renderPodium(null, []);
    }

    lastSyncMain.textContent = new Date().toLocaleTimeString();
  }

  async function saveUserState(nick, bal){
    const payload = {};
    if(nick !== undefined) payload.nickname = (nick||'').slice(0,MAX_NICK_LEN);
    if(bal !== undefined) payload.balance = Number(bal);
    const res = await apiPost(`/user/${encodeURIComponent(userId)}`, payload);
    return res;
  }

  // Hook into global setBalance (wrap) so server gets a save
  try{
    if(window.setBalance && typeof window.setBalance === 'function'){
      const _orig = window.setBalance.bind(window);
      window.setBalance = function(v){
        _orig(v);
        const balNow = window.balance || Number(document.getElementById('balance').textContent || 0);
        try{ localStorage.setItem('kf_balance', String(balNow)); }catch(e){}
        saveUserState(localStorage.getItem('kf_nickname') || '', balNow);
        setTimeout(()=>{ refreshAll(); }, 800);
      };
    }
  }catch(e){ console.warn('wrap setBalance failed', e); }

  (async function init(){
    nickname = (localStorage.getItem('kf_nickname') || '').slice(0,MAX_NICK_LEN);
    if(nickname){
      nickInputMain.value = nickname;
      nickModalInput.value = nickname;
    }

    // try server user
    const serverUser = await apiGet(`/user/${encodeURIComponent(userId)}`);
    if(serverUser && serverUser.user_id){
      if(serverUser.nickname){
        nickname = serverUser.nickname.slice(0,MAX_NICK_LEN);
        localStorage.setItem('kf_nickname', nickname);
        nickInputMain.value = nickname;
        nickModalInput.value = nickname;
      }
      if(typeof serverUser.balance !== 'undefined'){
        try{
          if(window.setBalance && typeof window.setBalance === 'function'){
            window.setBalance(Number(serverUser.balance));
          } else {
            document.getElementById('balance').textContent = Number(serverUser.balance).toFixed(2);
          }
        }catch(e){}
      }
    } else {
      const localBal = localStorage.getItem('kf_balance');
      if(localBal !== null){
        try{ if(window.setBalance) window.setBalance(Number(localBal)); else document.getElementById('balance').textContent = Number(localBal).toFixed(2); }catch(e){}
      }
      saveUserState(nickname || '', Number(document.getElementById('balance').textContent || 0));
    }

    localBalEl.textContent = (localStorage.getItem('kf_balance') || Number(document.getElementById('balance').textContent || 0)).toString();

    const seenNick = !!localStorage.getItem('kf_nickname');
    if(!seenNick){
      showNickModal(true);
    }

    await refreshAll();
    setInterval(refreshAll, 15000);
  })();

  // UI events
  leaderboardBtn.addEventListener('click', ()=> showLbModal(true));
  lbClose.addEventListener('click', ()=> showLbModal(false));
  refreshBtn.addEventListener('click', ()=> refreshAll());

  saveNickMain.addEventListener('click', async ()=>{
    const v = (nickInputMain.value || '').trim().slice(0,MAX_NICK_LEN);
    if(!v) return alert('Enter a nickname (max 40 chars)');
    nickname = v;
    localStorage.setItem('kf_nickname', nickname);
    nickModalInput.value = nickname;
    nickInputMain.value = nickname;
    await saveUserState(nickname, Number(document.getElementById('balance').textContent || 0));
    refreshAll();
  });

  // nickname modal actions
  nickModalSave.addEventListener('click', async ()=>{
    const v = (nickModalInput.value || '').trim().slice(0,MAX_NICK_LEN);
    if(!v) return alert('Enter a nickname (max 40 chars)');
    nickname = v;
    localStorage.setItem('kf_nickname', nickname);
    await saveUserState(nickname, Number(document.getElementById('balance').textContent || 0));
    showNickModal(false);
    refreshAll();
  });
  nickModalSkip.addEventListener('click', ()=>{
    localStorage.setItem('kf_nickname_skipped', '1');
    showNickModal(false);
  });

  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape'){
      if(lbModal.style.display === 'flex') showLbModal(false);
      if(nickModal.style.display === 'flex') showNickModal(false);
    }
  });

})();
</script>

</body>
</html>
